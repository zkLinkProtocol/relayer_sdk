/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
} from "ethers";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "@across-protocol/contracts/dist/typechain/common";

export declare namespace SpokePool {
  export type RelayExecutionInfoStruct = {
    recipient: string;
    message: BytesLike;
    relayerFeePct: BigNumberish;
    isSlowRelay: boolean;
    payoutAdjustmentPct: BigNumberish;
  };

  export type RelayExecutionInfoStructOutput = [
    string,
    string,
    BigNumber,
    boolean,
    BigNumber
  ] & {
    recipient: string;
    message: string;
    relayerFeePct: BigNumber;
    isSlowRelay: boolean;
    payoutAdjustmentPct: BigNumber;
  };
}

export declare namespace SpokePoolInterface {
  export type RelayerRefundLeafStruct = {
    amountToReturn: BigNumberish;
    chainId: BigNumberish;
    refundAmounts: BigNumberish[];
    leafId: BigNumberish;
    l2TokenAddress: string;
    refundAddresses: string[];
  };

  export type RelayerRefundLeafStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber[],
    number,
    string,
    string[]
  ] & {
    amountToReturn: BigNumber;
    chainId: BigNumber;
    refundAmounts: BigNumber[];
    leafId: number;
    l2TokenAddress: string;
    refundAddresses: string[];
  };
}

export declare namespace V3SpokePoolInterface {
  export type V3RelayDataStruct = {
    depositor: string;
    recipient: string;
    exclusiveRelayer: string;
    inputToken: string;
    outputToken: string;
    inputAmount: BigNumberish;
    outputAmount: BigNumberish;
    originChainId: BigNumberish;
    nonce: BigNumberish;
    fillDeadline: BigNumberish;
    exclusivityDeadline: BigNumberish;
    message: BytesLike;
  };

  export type V3RelayDataStructOutput = [
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    string
  ] & {
    depositor: string;
    recipient: string;
    exclusiveRelayer: string;
    inputToken: string;
    outputToken: string;
    inputAmount: BigNumber;
    outputAmount: BigNumber;
    originChainId: BigNumber;
    nonce: number;
    fillDeadline: number;
    exclusivityDeadline: number;
    message: string;
  };

  export type V3SlowFillStruct = {
    relayData: V3SpokePoolInterface.V3RelayDataStruct;
    chainId: BigNumberish;
    updatedOutputAmount: BigNumberish;
  };

  export type V3SlowFillStructOutput = [
    V3SpokePoolInterface.V3RelayDataStructOutput,
    BigNumber,
    BigNumber
  ] & {
    relayData: V3SpokePoolInterface.V3RelayDataStructOutput;
    chainId: BigNumber;
    updatedOutputAmount: BigNumber;
  };
}

export declare namespace MultiCallerUpgradeable {
  export type ResultStruct = { success: boolean; returnData: BytesLike };

  export type ResultStructOutput = [boolean, string] & {
    success: boolean;
    returnData: string;
  };
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<
  [string],
  BeaconUpgradedEventObject
>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface EmergencyDeleteRootBundleEventObject {
  rootBundleId: BigNumber;
}
export type EmergencyDeleteRootBundleEvent = TypedEvent<
  [BigNumber],
  EmergencyDeleteRootBundleEventObject
>;

export type EmergencyDeleteRootBundleEventFilter =
  TypedEventFilter<EmergencyDeleteRootBundleEvent>;

export interface EnabledDepositRouteEventObject {
  originToken: string;
  destinationChainId: BigNumber;
  enabled: boolean;
}
export type EnabledDepositRouteEvent = TypedEvent<
  [string, BigNumber, boolean],
  EnabledDepositRouteEventObject
>;

export type EnabledDepositRouteEventFilter =
  TypedEventFilter<EnabledDepositRouteEvent>;

export interface ExecutedRelayerRefundRootEventObject {
  amountToReturn: BigNumber;
  chainId: BigNumber;
  refundAmounts: BigNumber[];
  rootBundleId: number;
  leafId: number;
  l2TokenAddress: string;
  refundAddresses: string[];
  caller: string;
}
export type ExecutedRelayerRefundRootEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber[], number, number, string, string[], string],
  ExecutedRelayerRefundRootEventObject
>;

export type ExecutedRelayerRefundRootEventFilter =
  TypedEventFilter<ExecutedRelayerRefundRootEvent>;

export interface FilledRelayEventObject {
  amount: BigNumber;
  totalFilledAmount: BigNumber;
  fillAmount: BigNumber;
  repaymentChainId: BigNumber;
  originChainId: BigNumber;
  destinationChainId: BigNumber;
  relayerFeePct: BigNumber;
  realizedLpFeePct: BigNumber;
  nonce: number;
  destinationToken: string;
  relayer: string;
  depositor: string;
  recipient: string;
  message: string;
  updatableRelayData: SpokePool.RelayExecutionInfoStructOutput;
}
export type FilledRelayEvent = TypedEvent<
  [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    string,
    string,
    string,
    string,
    string,
    SpokePool.RelayExecutionInfoStructOutput
  ],
  FilledRelayEventObject
>;

export type FilledRelayEventFilter = TypedEventFilter<FilledRelayEvent>;

export interface FilledV3RelayEventObject {
  inputToken: string;
  outputToken: string;
  inputAmount: BigNumber;
  outputAmount: BigNumber;
  repaymentChainId: BigNumber;
  originChainId: BigNumber;
  nonce: number;
  fillDeadline: number;
  exclusivityDeadline: number;
  exclusiveRelayer: string;
  relayer: string;
  depositor: string;
  recipient: string;
  message: string;
  hash: string;
}
export type FilledV3RelayEvent = TypedEvent<
  [
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    string,
    string,
    string,
    string,
    string,
    string
  ],
  FilledV3RelayEventObject
>;

export type FilledV3RelayEventFilter = TypedEventFilter<FilledV3RelayEvent>;

export interface FundsDepositedEventObject {
  amount: BigNumber;
  originChainId: BigNumber;
  destinationChainId: BigNumber;
  relayerFeePct: BigNumber;
  nonce: number;
  quoteTimestamp: number;
  originToken: string;
  recipient: string;
  depositor: string;
  message: string;
}
export type FundsDepositedEvent = TypedEvent<
  [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    string,
    string,
    string,
    string
  ],
  FundsDepositedEventObject
>;

export type FundsDepositedEventFilter = TypedEventFilter<FundsDepositedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface PausedDepositsEventObject {
  isPaused: boolean;
}
export type PausedDepositsEvent = TypedEvent<
  [boolean],
  PausedDepositsEventObject
>;

export type PausedDepositsEventFilter = TypedEventFilter<PausedDepositsEvent>;

export interface PausedFillsEventObject {
  isPaused: boolean;
}
export type PausedFillsEvent = TypedEvent<[boolean], PausedFillsEventObject>;

export type PausedFillsEventFilter = TypedEventFilter<PausedFillsEvent>;

export interface RelayedRootBundleEventObject {
  rootBundleId: number;
  relayerRefundRoot: string;
  slowRelayRoot: string;
}
export type RelayedRootBundleEvent = TypedEvent<
  [number, string, string],
  RelayedRootBundleEventObject
>;

export type RelayedRootBundleEventFilter =
  TypedEventFilter<RelayedRootBundleEvent>;

export interface RequestedSpeedUpDepositEventObject {
  newRelayerFeePct: BigNumber;
  depositId: number;
  depositor: string;
  updatedRecipient: string;
  updatedMessage: string;
  depositorSignature: string;
}
export type RequestedSpeedUpDepositEvent = TypedEvent<
  [BigNumber, number, string, string, string, string],
  RequestedSpeedUpDepositEventObject
>;

export type RequestedSpeedUpDepositEventFilter =
  TypedEventFilter<RequestedSpeedUpDepositEvent>;

export interface RequestedSpeedUpV3DepositEventObject {
  updatedOutputAmount: BigNumber;
  depositId: number;
  depositor: string;
  updatedRecipient: string;
  updatedMessage: string;
  depositorSignature: string;
}
export type RequestedSpeedUpV3DepositEvent = TypedEvent<
  [BigNumber, number, string, string, string, string],
  RequestedSpeedUpV3DepositEventObject
>;

export type RequestedSpeedUpV3DepositEventFilter =
  TypedEventFilter<RequestedSpeedUpV3DepositEvent>;

export interface RequestedV3SlowFillEventObject {
  inputToken: string;
  outputToken: string;
  inputAmount: BigNumber;
  outputAmount: BigNumber;
  originChainId: BigNumber;
  depositId: number;
  fillDeadline: number;
  exclusivityDeadline: number;
  exclusiveRelayer: string;
  depositor: string;
  recipient: string;
  message: string;
}
export type RequestedV3SlowFillEvent = TypedEvent<
  [
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    string,
    string,
    string,
    string
  ],
  RequestedV3SlowFillEventObject
>;

export type RequestedV3SlowFillEventFilter =
  TypedEventFilter<RequestedV3SlowFillEvent>;

export interface SetHubPoolEventObject {
  newHubPool: string;
}
export type SetHubPoolEvent = TypedEvent<[string], SetHubPoolEventObject>;

export type SetHubPoolEventFilter = TypedEventFilter<SetHubPoolEvent>;

export interface SetXDomainAdminEventObject {
  newAdmin: string;
}
export type SetXDomainAdminEvent = TypedEvent<
  [string],
  SetXDomainAdminEventObject
>;

export type SetXDomainAdminEventFilter = TypedEventFilter<SetXDomainAdminEvent>;

export interface SetZkBridgeEventObject {
  erc20Bridge: string;
  oldErc20Bridge: string;
}
export type SetZkBridgeEvent = TypedEvent<
  [string, string],
  SetZkBridgeEventObject
>;

export type SetZkBridgeEventFilter = TypedEventFilter<SetZkBridgeEvent>;

export interface TokensBridgedEventObject {
  amountToReturn: BigNumber;
  chainId: BigNumber;
  leafId: number;
  l2TokenAddress: string;
  caller: string;
}
export type TokensBridgedEvent = TypedEvent<
  [BigNumber, BigNumber, number, string, string],
  TokensBridgedEventObject
>;

export type TokensBridgedEventFilter = TypedEventFilter<TokensBridgedEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface V3FundsDepositedEventObject {
  inputToken: string;
  outputToken: string;
  inputAmount: BigNumber;
  outputAmount: BigNumber;
  destinationChainId: BigNumber;
  nonce: number;
  quoteTimestamp: number;
  fillDeadline: number;
  exclusivityDeadline: number;
  depositor: string;
  recipient: string;
  exclusiveRelayer: string;
  message: string;
}
export type V3FundsDepositedEvent = TypedEvent<
  [
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    number,
    string,
    string,
    string,
    string
  ],
  V3FundsDepositedEventObject
>;

export type V3FundsDepositedEventFilter =
  TypedEventFilter<V3FundsDepositedEvent>;

export interface SpokePool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;
  queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;
  functions: {
      EMPTY_RELAYER(overrides?: CallOverrides): Promise<[string]>;
      EMPTY_REPAYMENT_CHAIN_ID(overrides?: CallOverrides): Promise<[BigNumber]>;
      INFINITE_FILL_DEADLINE(overrides?: CallOverrides): Promise<[number]>;
      MAX_TRANSFER_SIZE(overrides?: CallOverrides): Promise<[BigNumber]>;
      UPDATE_V3_DEPOSIT_DETAILS_HASH(overrides?: CallOverrides): Promise<[string]>;
      __SpokePool_init(_initialDepositId: BigNumberish, _crossDomainAdmin: string, _hubPool: string, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      chainId(overrides?: CallOverrides): Promise<[BigNumber]>;
      crossDomainAdmin(overrides?: CallOverrides): Promise<[string]>;
      deposit(recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg7: BigNumberish, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      depositExclusive(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadlineOffset: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      depositFor(depositor: string, recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg8: BigNumberish, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      depositQuoteTimeBuffer(overrides?: CallOverrides): Promise<[number]>;
      depositV3(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      depositV3Now(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, fillDeadlineOffset: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      emergencyDeleteRootBundle(rootBundleId: BigNumberish, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      enabledDepositRoutes(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>;
      executeRelayerRefundLeaf(rootBundleId: BigNumberish, relayerRefundLeaf: SpokePoolInterface.RelayerRefundLeafStruct, proof: BytesLike[], overrides?: PayableOverrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      executeV3SlowRelayLeaf(slowFillLeaf: V3SpokePoolInterface.V3SlowFillStruct, rootBundleId: BigNumberish, proof: BytesLike[], overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      fillDeadlineBuffer(overrides?: CallOverrides): Promise<[number]>;
      fillStatuses(arg0: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;
      fillV3Relay(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      fillRelay(
        relayData: V3SpokePoolInterface.V3RelayDataStruct,
        repaymentChainId: BigNumberish,
        _l2TxGasLimit: BigNumberish,
        _l2GasPerPubdataByteLimit: BigNumberish,
        _refundRecipient: string,
        _l2Recipient: string,
        overrides?: PayableOverrides & { from?: string }
      ): Promise<ContractTransaction>;
      fillV3RelayWithUpdatedDeposit(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      getCurrentTime(overrides?: CallOverrides): Promise<[BigNumber]>;
      hubPool(overrides?: CallOverrides): Promise<[string]>;
      multicall(data: BytesLike[], overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      nonce(from: string, overrides?: CallOverrides): Promise<[number]>;
      pauseDeposits(pause: boolean, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      pauseFills(pause: boolean, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      pausedDeposits(overrides?: CallOverrides): Promise<[boolean]>;
      pausedFills(overrides?: CallOverrides): Promise<[boolean]>;
      proxiableUUID(overrides?: CallOverrides): Promise<[string]>;
      relayRootBundle(relayerRefundRoot: BytesLike, slowRelayRoot: BytesLike, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      requestV3SlowFill(relayData: V3SpokePoolInterface.V3RelayDataStruct, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      rootBundles(arg0: BigNumberish, overrides?: CallOverrides): Promise<[
          string,
          string
      ] & {
          slowRelayRoot: string;
          relayerRefundRoot: string;
      }>;
      setCrossDomainAdmin(newCrossDomainAdmin: string, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      setEnableRoute(originToken: string, destinationChainId: BigNumberish, enabled: boolean, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      setHubPool(newHubPool: string, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      speedUpV3Deposit(depositor: string, depositId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      tryMulticall(data: BytesLike[], overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      upgradeTo(newImplementation: string, overrides?: Overrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      upgradeToAndCall(newImplementation: string, data: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<ContractTransaction>;
      wrappedNativeToken(overrides?: CallOverrides): Promise<[string]>;
  };
  EMPTY_RELAYER(overrides?: CallOverrides): Promise<string>;
  EMPTY_REPAYMENT_CHAIN_ID(overrides?: CallOverrides): Promise<BigNumber>;
  INFINITE_FILL_DEADLINE(overrides?: CallOverrides): Promise<number>;
  MAX_TRANSFER_SIZE(overrides?: CallOverrides): Promise<BigNumber>;
  UPDATE_V3_DEPOSIT_DETAILS_HASH(overrides?: CallOverrides): Promise<string>;
  __SpokePool_init(_initialDepositId: BigNumberish, _crossDomainAdmin: string, _hubPool: string, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  chainId(overrides?: CallOverrides): Promise<BigNumber>;
  crossDomainAdmin(overrides?: CallOverrides): Promise<string>;
  deposit(recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg7: BigNumberish, overrides?: PayableOverrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  depositExclusive(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadlineOffset: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  depositFor(depositor: string, recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg8: BigNumberish, overrides?: PayableOverrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  depositQuoteTimeBuffer(overrides?: CallOverrides): Promise<number>;
  depositV3(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  depositV3Now(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, fillDeadlineOffset: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  emergencyDeleteRootBundle(rootBundleId: BigNumberish, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  enabledDepositRoutes(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
  executeRelayerRefundLeaf(rootBundleId: BigNumberish, relayerRefundLeaf: SpokePoolInterface.RelayerRefundLeafStruct, proof: BytesLike[], overrides?: PayableOverrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  executeV3SlowRelayLeaf(slowFillLeaf: V3SpokePoolInterface.V3SlowFillStruct, rootBundleId: BigNumberish, proof: BytesLike[], overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  fillDeadlineBuffer(overrides?: CallOverrides): Promise<number>;
  fillStatuses(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
  fillV3Relay(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  testfillV3Relay(
    relayData: V3SpokePoolInterface.V3RelayDataStruct,
    repaymentChainId: BigNumberish,
    _l2TxGasLimit: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;
  fillV3RelayWithUpdatedDeposit(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;
  hubPool(overrides?: CallOverrides): Promise<string>;
  multicall(data: BytesLike[], overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  nonce(from: string, overrides?: CallOverrides): Promise<number>;
  pauseDeposits(pause: boolean, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  pauseFills(pause: boolean, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  pausedDeposits(overrides?: CallOverrides): Promise<boolean>;
  pausedFills(overrides?: CallOverrides): Promise<boolean>;
  proxiableUUID(overrides?: CallOverrides): Promise<string>;
  relayRootBundle(relayerRefundRoot: BytesLike, slowRelayRoot: BytesLike, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  requestV3SlowFill(relayData: V3SpokePoolInterface.V3RelayDataStruct, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  rootBundles(arg0: BigNumberish, overrides?: CallOverrides): Promise<[
      string,
      string
  ] & {
      slowRelayRoot: string;
      relayerRefundRoot: string;
  }>;
  setCrossDomainAdmin(newCrossDomainAdmin: string, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  setEnableRoute(originToken: string, destinationChainId: BigNumberish, enabled: boolean, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  setHubPool(newHubPool: string, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  speedUpV3Deposit(depositor: string, depositId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  tryMulticall(data: BytesLike[], overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  upgradeTo(newImplementation: string, overrides?: Overrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  upgradeToAndCall(newImplementation: string, data: BytesLike, overrides?: PayableOverrides & {
      from?: string;
  }): Promise<ContractTransaction>;
  wrappedNativeToken(overrides?: CallOverrides): Promise<string>;
  callStatic: {
      EMPTY_RELAYER(overrides?: CallOverrides): Promise<string>;
      EMPTY_REPAYMENT_CHAIN_ID(overrides?: CallOverrides): Promise<BigNumber>;
      INFINITE_FILL_DEADLINE(overrides?: CallOverrides): Promise<number>;
      MAX_TRANSFER_SIZE(overrides?: CallOverrides): Promise<BigNumber>;
      UPDATE_V3_DEPOSIT_DETAILS_HASH(overrides?: CallOverrides): Promise<string>;
      __SpokePool_init(_initialDepositId: BigNumberish, _crossDomainAdmin: string, _hubPool: string, overrides?: CallOverrides): Promise<void>;
      chainId(overrides?: CallOverrides): Promise<BigNumber>;
      crossDomainAdmin(overrides?: CallOverrides): Promise<string>;
      deposit(recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg7: BigNumberish, overrides?: CallOverrides): Promise<void>;
      depositExclusive(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadlineOffset: BigNumberish, message: BytesLike, overrides?: CallOverrides): Promise<void>;
      depositFor(depositor: string, recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg8: BigNumberish, overrides?: CallOverrides): Promise<void>;
      depositQuoteTimeBuffer(overrides?: CallOverrides): Promise<number>;
      depositV3(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: CallOverrides): Promise<void>;
      depositV3Now(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, fillDeadlineOffset: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: CallOverrides): Promise<void>;
      emergencyDeleteRootBundle(rootBundleId: BigNumberish, overrides?: CallOverrides): Promise<void>;
      enabledDepositRoutes(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
      executeRelayerRefundLeaf(rootBundleId: BigNumberish, relayerRefundLeaf: SpokePoolInterface.RelayerRefundLeafStruct, proof: BytesLike[], overrides?: CallOverrides): Promise<void>;
      executeV3SlowRelayLeaf(slowFillLeaf: V3SpokePoolInterface.V3SlowFillStruct, rootBundleId: BigNumberish, proof: BytesLike[], overrides?: CallOverrides): Promise<void>;
      fillDeadlineBuffer(overrides?: CallOverrides): Promise<number>;
      fillStatuses(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
      fillV3Relay(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, overrides?: CallOverrides): Promise<void>;
      testFillv3Relay(
        relayData: V3SpokePoolInterface.V3RelayDataStruct,
        repaymentChainId: BigNumberish,
        _l2TxGasLimit: BigNumberish,
        overrides?: CallOverrides
      ): Promise<string>;
      fillV3RelayWithUpdatedDeposit(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: CallOverrides): Promise<void>;
      getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;
      hubPool(overrides?: CallOverrides): Promise<string>;
      multicall(data: BytesLike[], overrides?: CallOverrides): Promise<string[]>;
      nonce(from: string, overrides?: CallOverrides): Promise<number>;
      pauseDeposits(pause: boolean, overrides?: CallOverrides): Promise<void>;
      pauseFills(pause: boolean, overrides?: CallOverrides): Promise<void>;
      pausedDeposits(overrides?: CallOverrides): Promise<boolean>;
      pausedFills(overrides?: CallOverrides): Promise<boolean>;
      proxiableUUID(overrides?: CallOverrides): Promise<string>;
      relayRootBundle(relayerRefundRoot: BytesLike, slowRelayRoot: BytesLike, overrides?: CallOverrides): Promise<void>;
      requestV3SlowFill(relayData: V3SpokePoolInterface.V3RelayDataStruct, overrides?: CallOverrides): Promise<void>;
      rootBundles(arg0: BigNumberish, overrides?: CallOverrides): Promise<[
          string,
          string
      ] & {
          slowRelayRoot: string;
          relayerRefundRoot: string;
      }>;
      setCrossDomainAdmin(newCrossDomainAdmin: string, overrides?: CallOverrides): Promise<void>;
      setEnableRoute(originToken: string, destinationChainId: BigNumberish, enabled: boolean, overrides?: CallOverrides): Promise<void>;
      setHubPool(newHubPool: string, overrides?: CallOverrides): Promise<void>;
      speedUpV3Deposit(depositor: string, depositId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: CallOverrides): Promise<void>;
      tryMulticall(data: BytesLike[], overrides?: CallOverrides): Promise<MultiCallerUpgradeable.ResultStructOutput[]>;
      upgradeTo(newImplementation: string, overrides?: CallOverrides): Promise<void>;
      upgradeToAndCall(newImplementation: string, data: BytesLike, overrides?: CallOverrides): Promise<void>;
      wrappedNativeToken(overrides?: CallOverrides): Promise<string>;
  };
  filters: {
      "AdminChanged(address,address)"(previousAdmin?: null, newAdmin?: null): AdminChangedEventFilter;
      AdminChanged(previousAdmin?: null, newAdmin?: null): AdminChangedEventFilter;
      "BeaconUpgraded(address)"(beacon?: string | null): BeaconUpgradedEventFilter;
      BeaconUpgraded(beacon?: string | null): BeaconUpgradedEventFilter;
      "EmergencyDeleteRootBundle(uint256)"(rootBundleId?: BigNumberish | null): EmergencyDeleteRootBundleEventFilter;
      EmergencyDeleteRootBundle(rootBundleId?: BigNumberish | null): EmergencyDeleteRootBundleEventFilter;
      "EnabledDepositRoute(address,uint256,bool)"(originToken?: string | null, destinationChainId?: BigNumberish | null, enabled?: null): EnabledDepositRouteEventFilter;
      EnabledDepositRoute(originToken?: string | null, destinationChainId?: BigNumberish | null, enabled?: null): EnabledDepositRouteEventFilter;
      "ExecutedRelayerRefundRoot(uint256,uint256,uint256[],uint32,uint32,address,address[],address)"(amountToReturn?: null, chainId?: BigNumberish | null, refundAmounts?: null, rootBundleId?: BigNumberish | null, leafId?: BigNumberish | null, l2TokenAddress?: null, refundAddresses?: null, caller?: null): ExecutedRelayerRefundRootEventFilter;
      ExecutedRelayerRefundRoot(amountToReturn?: null, chainId?: BigNumberish | null, refundAmounts?: null, rootBundleId?: BigNumberish | null, leafId?: BigNumberish | null, l2TokenAddress?: null, refundAddresses?: null, caller?: null): ExecutedRelayerRefundRootEventFilter;
      "FilledRelay(uint256,uint256,uint256,uint256,uint256,uint256,int64,int64,uint32,address,address,address,address,bytes,tuple)"(amount?: null, totalFilledAmount?: null, fillAmount?: null, repaymentChainId?: null, originChainId?: BigNumberish | null, destinationChainId?: null, relayerFeePct?: null, realizedLpFeePct?: null, depositId?: BigNumberish | null, destinationToken?: null, relayer?: null, depositor?: string | null, recipient?: null, message?: null, updatableRelayData?: null): FilledRelayEventFilter;
      FilledRelay(amount?: null, totalFilledAmount?: null, fillAmount?: null, repaymentChainId?: null, originChainId?: BigNumberish | null, destinationChainId?: null, relayerFeePct?: null, realizedLpFeePct?: null, depositId?: BigNumberish | null, destinationToken?: null, relayer?: null, depositor?: string | null, recipient?: null, message?: null, updatableRelayData?: null): FilledRelayEventFilter;
      "FilledV3Relay(address,address,uint256,uint256,uint256,uint256,uint32,uint32,uint32,address,address,address,address,bytes,tuple)"(inputToken?: null, outputToken?: null, inputAmount?: null, outputAmount?: null, repaymentChainId?: null, originChainId?: BigNumberish | null, depositId?: BigNumberish | null, fillDeadline?: null, exclusivityDeadline?: null, exclusiveRelayer?: null, relayer?: string | null, depositor?: null, recipient?: null, message?: null, relayExecutionInfo?: null): FilledV3RelayEventFilter;
      FilledV3Relay(inputToken?: null, outputToken?: null, inputAmount?: null, outputAmount?: null, repaymentChainId?: null, originChainId?: BigNumberish | null, depositId?: BigNumberish | null, fillDeadline?: null, exclusivityDeadline?: null, exclusiveRelayer?: null, relayer?: string | null, depositor?: null, recipient?: null, message?: null, relayExecutionInfo?: null): FilledV3RelayEventFilter;
      "FundsDeposited(uint256,uint256,uint256,int64,uint32,uint32,address,address,address,bytes)"(amount?: null, originChainId?: null, destinationChainId?: BigNumberish | null, relayerFeePct?: null, depositId?: BigNumberish | null, quoteTimestamp?: null, originToken?: null, recipient?: null, depositor?: string | null, message?: null): FundsDepositedEventFilter;
      FundsDeposited(amount?: null, originChainId?: null, destinationChainId?: BigNumberish | null, relayerFeePct?: null, depositId?: BigNumberish | null, quoteTimestamp?: null, originToken?: null, recipient?: null, depositor?: string | null, message?: null): FundsDepositedEventFilter;
      "Initialized(uint8)"(version?: null): InitializedEventFilter;
      Initialized(version?: null): InitializedEventFilter;
      "PausedDeposits(bool)"(isPaused?: null): PausedDepositsEventFilter;
      PausedDeposits(isPaused?: null): PausedDepositsEventFilter;
      "PausedFills(bool)"(isPaused?: null): PausedFillsEventFilter;
      PausedFills(isPaused?: null): PausedFillsEventFilter;
      "RelayedRootBundle(uint32,bytes32,bytes32)"(rootBundleId?: BigNumberish | null, relayerRefundRoot?: BytesLike | null, slowRelayRoot?: BytesLike | null): RelayedRootBundleEventFilter;
      RelayedRootBundle(rootBundleId?: BigNumberish | null, relayerRefundRoot?: BytesLike | null, slowRelayRoot?: BytesLike | null): RelayedRootBundleEventFilter;
      "RequestedSpeedUpDeposit(int64,uint32,address,address,bytes,bytes)"(newRelayerFeePct?: null, depositId?: BigNumberish | null, depositor?: string | null, updatedRecipient?: null, updatedMessage?: null, depositorSignature?: null): RequestedSpeedUpDepositEventFilter;
      RequestedSpeedUpDeposit(newRelayerFeePct?: null, depositId?: BigNumberish | null, depositor?: string | null, updatedRecipient?: null, updatedMessage?: null, depositorSignature?: null): RequestedSpeedUpDepositEventFilter;
      "RequestedSpeedUpV3Deposit(uint256,uint32,address,address,bytes,bytes)"(updatedOutputAmount?: null, depositId?: BigNumberish | null, depositor?: string | null, updatedRecipient?: null, updatedMessage?: null, depositorSignature?: null): RequestedSpeedUpV3DepositEventFilter;
      RequestedSpeedUpV3Deposit(updatedOutputAmount?: null, depositId?: BigNumberish | null, depositor?: string | null, updatedRecipient?: null, updatedMessage?: null, depositorSignature?: null): RequestedSpeedUpV3DepositEventFilter;
      "RequestedV3SlowFill(address,address,uint256,uint256,uint256,uint32,uint32,uint32,address,address,address,bytes)"(inputToken?: null, outputToken?: null, inputAmount?: null, outputAmount?: null, originChainId?: BigNumberish | null, depositId?: BigNumberish | null, fillDeadline?: null, exclusivityDeadline?: null, exclusiveRelayer?: null, depositor?: null, recipient?: null, message?: null): RequestedV3SlowFillEventFilter;
      RequestedV3SlowFill(inputToken?: null, outputToken?: null, inputAmount?: null, outputAmount?: null, originChainId?: BigNumberish | null, depositId?: BigNumberish | null, fillDeadline?: null, exclusivityDeadline?: null, exclusiveRelayer?: null, depositor?: null, recipient?: null, message?: null): RequestedV3SlowFillEventFilter;
      "SetHubPool(address)"(newHubPool?: string | null): SetHubPoolEventFilter;
      SetHubPool(newHubPool?: string | null): SetHubPoolEventFilter;
      "SetXDomainAdmin(address)"(newAdmin?: string | null): SetXDomainAdminEventFilter;
      SetXDomainAdmin(newAdmin?: string | null): SetXDomainAdminEventFilter;
      "TokensBridged(uint256,uint256,uint32,address,address)"(amountToReturn?: null, chainId?: BigNumberish | null, leafId?: BigNumberish | null, l2TokenAddress?: string | null, caller?: null): TokensBridgedEventFilter;
      TokensBridged(amountToReturn?: null, chainId?: BigNumberish | null, leafId?: BigNumberish | null, l2TokenAddress?: string | null, caller?: null): TokensBridgedEventFilter;
      "Upgraded(address)"(implementation?: string | null): UpgradedEventFilter;
      Upgraded(implementation?: string | null): UpgradedEventFilter;
      "V3FundsDeposited(address,address,uint256,uint256,uint256,uint32,uint32,uint32,uint32,address,address,address,bytes)"(inputToken?: null, outputToken?: null, inputAmount?: null, outputAmount?: null, destinationChainId?: BigNumberish | null, depositId?: BigNumberish | null, quoteTimestamp?: null, fillDeadline?: null, exclusivityDeadline?: null, depositor?: string | null, recipient?: null, exclusiveRelayer?: null, message?: null): V3FundsDepositedEventFilter;
      V3FundsDeposited(inputToken?: null, outputToken?: null, inputAmount?: null, outputAmount?: null, destinationChainId?: BigNumberish | null, depositId?: BigNumberish | null, quoteTimestamp?: null, fillDeadline?: null, exclusivityDeadline?: null, depositor?: string | null, recipient?: null, exclusiveRelayer?: null, message?: null): V3FundsDepositedEventFilter;
  };
  estimateGas: {
      EMPTY_RELAYER(overrides?: CallOverrides): Promise<BigNumber>;
      EMPTY_REPAYMENT_CHAIN_ID(overrides?: CallOverrides): Promise<BigNumber>;
      INFINITE_FILL_DEADLINE(overrides?: CallOverrides): Promise<BigNumber>;
      MAX_TRANSFER_SIZE(overrides?: CallOverrides): Promise<BigNumber>;
      UPDATE_V3_DEPOSIT_DETAILS_HASH(overrides?: CallOverrides): Promise<BigNumber>;
      __SpokePool_init(_initialDepositId: BigNumberish, _crossDomainAdmin: string, _hubPool: string, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      chainId(overrides?: CallOverrides): Promise<BigNumber>;
      crossDomainAdmin(overrides?: CallOverrides): Promise<BigNumber>;
      deposit(recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg7: BigNumberish, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<BigNumber>;
      depositExclusive(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadlineOffset: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<BigNumber>;
      depositFor(depositor: string, recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg8: BigNumberish, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<BigNumber>;
      depositQuoteTimeBuffer(overrides?: CallOverrides): Promise<BigNumber>;
      depositV3(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<BigNumber>;
      depositV3Now(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, fillDeadlineOffset: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<BigNumber>;
      emergencyDeleteRootBundle(rootBundleId: BigNumberish, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      enabledDepositRoutes(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
      executeRelayerRefundLeaf(rootBundleId: BigNumberish, relayerRefundLeaf: SpokePoolInterface.RelayerRefundLeafStruct, proof: BytesLike[], overrides?: PayableOverrides & {
          from?: string;
      }): Promise<BigNumber>;
      executeV3SlowRelayLeaf(slowFillLeaf: V3SpokePoolInterface.V3SlowFillStruct, rootBundleId: BigNumberish, proof: BytesLike[], overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      fillDeadlineBuffer(overrides?: CallOverrides): Promise<BigNumber>;
      fillStatuses(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
      fillV3Relay(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      testFillv3Relay(
        relayData: V3SpokePoolInterface.V3RelayDataStruct,
        repaymentChainId: BigNumberish,
        _l2TxGasLimit: BigNumberish,
        overrides?: PayableOverrides & { from?: string }
      ): Promise<BigNumber>;
      fillV3RelayWithUpdatedDeposit(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;
      hubPool(overrides?: CallOverrides): Promise<BigNumber>;
      multicall(data: BytesLike[], overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      nonce(from: string, overrides?: CallOverrides): Promise<BigNumber>;
      pauseDeposits(pause: boolean, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      pauseFills(pause: boolean, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      pausedDeposits(overrides?: CallOverrides): Promise<BigNumber>;
      pausedFills(overrides?: CallOverrides): Promise<BigNumber>;
      proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;
      relayRootBundle(relayerRefundRoot: BytesLike, slowRelayRoot: BytesLike, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      requestV3SlowFill(relayData: V3SpokePoolInterface.V3RelayDataStruct, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      rootBundles(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
      setCrossDomainAdmin(newCrossDomainAdmin: string, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      setEnableRoute(originToken: string, destinationChainId: BigNumberish, enabled: boolean, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      setHubPool(newHubPool: string, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      speedUpV3Deposit(depositor: string, depositId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      tryMulticall(data: BytesLike[], overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      upgradeTo(newImplementation: string, overrides?: Overrides & {
          from?: string;
      }): Promise<BigNumber>;
      upgradeToAndCall(newImplementation: string, data: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<BigNumber>;
      wrappedNativeToken(overrides?: CallOverrides): Promise<BigNumber>;
  };
  populateTransaction: {
      EMPTY_RELAYER(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      EMPTY_REPAYMENT_CHAIN_ID(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      INFINITE_FILL_DEADLINE(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      MAX_TRANSFER_SIZE(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      UPDATE_V3_DEPOSIT_DETAILS_HASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      __SpokePool_init(_initialDepositId: BigNumberish, _crossDomainAdmin: string, _hubPool: string, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      chainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      crossDomainAdmin(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      deposit(recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg7: BigNumberish, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      depositExclusive(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadlineOffset: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      depositFor(depositor: string, recipient: string, originToken: string, amount: BigNumberish, destinationChainId: BigNumberish, relayerFeePct: BigNumberish, quoteTimestamp: BigNumberish, message: BytesLike, arg8: BigNumberish, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      depositQuoteTimeBuffer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      depositV3(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, quoteTimestamp: BigNumberish, fillDeadline: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      depositV3Now(depositor: string, recipient: string, inputToken: string, outputToken: string, inputAmount: BigNumberish, outputAmount: BigNumberish, destinationChainId: BigNumberish, exclusiveRelayer: string, fillDeadlineOffset: BigNumberish, exclusivityDeadline: BigNumberish, message: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      emergencyDeleteRootBundle(rootBundleId: BigNumberish, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      enabledDepositRoutes(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
      executeRelayerRefundLeaf(rootBundleId: BigNumberish, relayerRefundLeaf: SpokePoolInterface.RelayerRefundLeafStruct, proof: BytesLike[], overrides?: PayableOverrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      executeV3SlowRelayLeaf(slowFillLeaf: V3SpokePoolInterface.V3SlowFillStruct, rootBundleId: BigNumberish, proof: BytesLike[], overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      fillDeadlineBuffer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      fillStatuses(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
      fillV3Relay(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      testFillv3Relay(
        relayData: V3SpokePoolInterface.V3RelayDataStruct,
        repaymentChainId: BigNumberish,
        _l2TxGasLimit: BigNumberish,
        overrides?: PayableOverrides & { from?: string }
      ): Promise<PopulatedTransaction>;
      fillV3RelayWithUpdatedDeposit(relayData: V3SpokePoolInterface.V3RelayDataStruct, repaymentChainId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      getCurrentTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      hubPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      multicall(data: BytesLike[], overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      nonce(from: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
      pauseDeposits(pause: boolean, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      pauseFills(pause: boolean, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      pausedDeposits(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      pausedFills(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;
      relayRootBundle(relayerRefundRoot: BytesLike, slowRelayRoot: BytesLike, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      requestV3SlowFill(relayData: V3SpokePoolInterface.V3RelayDataStruct, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      rootBundles(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
      setCrossDomainAdmin(newCrossDomainAdmin: string, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      setEnableRoute(originToken: string, destinationChainId: BigNumberish, enabled: boolean, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      setHubPool(newHubPool: string, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      speedUpV3Deposit(depositor: string, depositId: BigNumberish, updatedOutputAmount: BigNumberish, updatedRecipient: string, updatedMessage: BytesLike, depositorSignature: BytesLike, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      tryMulticall(data: BytesLike[], overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      upgradeTo(newImplementation: string, overrides?: Overrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      upgradeToAndCall(newImplementation: string, data: BytesLike, overrides?: PayableOverrides & {
          from?: string;
      }): Promise<PopulatedTransaction>;
      wrappedNativeToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
